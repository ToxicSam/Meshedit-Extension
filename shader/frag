uniform int outputID;
uniform sampler2D envmap;
uniform vec3 eyePos;
varying vec3 normal;
varying vec3 vertex;

#define PI 3.1415926

vec3 shadeDiffuseFromEye();

vec3 shadePhong(vec3 lightPos);

vec3 shadePhongAmerican(vec3 lightPos);

vec3 shadeEnvmapReflection();

void main()
{
    if(outputID == 0)
    {
        gl_FragColor = vec4(shadeDiffuseFromEye(), 1.0);
        return;
    }
    if(outputID == 1)
    {
        gl_FragColor = vec4(shadePhong(vec3(10, 10, 10)), 1.0);
        return;
    }
    if(outputID == 2)
    {
        gl_FragColor = vec4(shadeEnvmapReflection(), 1.0);
        return;
    }
    if(outputID == 3)
    {
        gl_FragColor = vec4(shadePhongAmerican(vec3(10, 10, 10)), 1.0);
        return;
    }
    // ...
}

vec3 shadeDiffuseFromEye()
{
    vec3 n = normalize(normal);
    vec3 out_vec = normalize(eyePos - vertex);
    float diffuse = abs(dot(out_vec, n));
    return vec3(diffuse);
}

vec3 shadePhong(vec3 lightPos)
{   // TODO Part 6.
    // TODO Compute Phong shading here. You can choose any color you like. But please
    // TODO make sure that you have noticeable specular highlights in the shading.
    // TODO Variables to use: eyePos, lightPos, normal, vertex

    float ia = .002; 
    float p = 32.0;

    vec3 ka = vec3(25.0,25.0,112.0);
    vec3 kd = vec3(25.0,25.0,112.0);
    vec3 ks = vec3(255.0,255.0,255.0);
  
    vec3 n = normalize(normal);
    vec3 l = normalize(lightPos - vertex);
    vec3 v = normalize(eyePos - vertex);

    float diffuseFactor = (1.0 / (distance(lightPos, vertex) * distance(lightPos, vertex))) * max(0.0, dot(n, l));

    vec3 h = normalize(v + l);

    float specularFactor = (1.0 / (distance(lightPos, vertex) * distance(lightPos, vertex))) * pow(max(0.0, dot(n, h)), p);


    return ia * ka + kd * diffuseFactor + ks * specularFactor;
}

vec3 shadePhongAmerican(vec3 lightPos)
{  
    float ia = .0005; 
    float p = 32.0;

    vec3 ka = vec3(255.0,0.0,0.0);
    vec3 kd = vec3(25.0,25.0,112.0);
    vec3 ks = vec3(255.0,255.0,255.0);
  
    vec3 n = normalize(normal);
    vec3 l = normalize(lightPos - vertex);
    vec3 v = normalize(eyePos - vertex);

    float diffuseFactor = (1.0 / (distance(lightPos, vertex) * distance(lightPos, vertex))) * max(0.0, dot(n, l));

    vec3 h = normalize(v + l);

    float specularFactor = (1.0 / (distance(lightPos, vertex) * distance(lightPos, vertex))) * pow(max(0.0, dot(n, h)), p);


    return ia * ka + kd * diffuseFactor + ks * specularFactor;
}

vec3 shadeEnvmapReflection()
{   // TODO Part 6.
    // TODO Compute environment mapping based on reflection direction here.
    // TODO First compute the reflection direction using eyePos, normal and vertex.
    // TODO Then convert the reflection direction to spherical coordinates (theta, phi). 
    // TODO Note that the up vector is along +Z axis.
    // TODO Finally, grab the color from envmap using (theta, phi).
    // TODO You will need to use function "vec4 texture2D(sampler2D tex, vec2 uv)" to 
    // TODO get colors from textures. 

    vec3 n = normalize(normal);
    vec3 i = normalize(eyePos - vertex);

    vec3 o = 2.0 * (dot(i, n)) * n - i;

    float theta = atan(o.y / o.x);
    float phi = atan(pow(pow(o.x, 2.0) + pow(o.y, 2.0),.50)/o.z);

    float u = theta / (2.0 * PI);
    float v = phi / PI;

    vec4 texcolor = texture2D(envmap, vec2(u,v));
    
    return vec3(texcolor.x, texcolor.y, texcolor.z);
}
