<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<style>  
    div.padded {  
      padding-top: 0px;  
      padding-right: 100px;  
      padding-bottom: 0.25in;  
      padding-left: 100px;  
    }  
  </style> 
<title>Meshedit Extension  |  CS 184</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="style.css" media="screen" />
</head>
<body>
<br />
<h1 align="middle">Final Report for Meshedit Extension</h1>
    <h2 align="middle">By Nag Alluri, Kenny Chung, Tim Greeno</h2>

    <h2 align="middle">Abstract</h2>
    <!-- A paragraph summary of the entire project. -->
    <p>Triangular meshes are ubiquitous in the world of graphics, used in diverse applications from 3D modeling to video game development. Thus, the ability to manipulate meshes to fit one's needs -- whether they are performance or detail oriented -- is paramount. With that in mind, we decided to unlock more of our existing mesh code's potential by implementing a diverse set of functionality: edge collapse, remeshing, mesh simplification, alternate upsampling, and new shaders.</p>

            <p> This is the main problem that our project will attempt to address--modifying mesh models in a way that reduces the various costs associated with their use.
            The two methods for doing this we will employ are remeshing and mesh simplification. 
            Remeshing is the act of modifying the mesh such that the triangles that make it up are near-equilateral and have similar areas. 
            This makes the process of editing the mesh more efficient and allows algorithms on the mesh to be more robust. 
            Mesh simplification revolves around simplifying the mesh, which makes most operations on the mesh more efficient because it is less complex.
            This can be a difficult process, because the algorithm should ideally preserve as much detail of the original mesh as possible.
        </p>
        <p> For our project, we plan to integrate these two process into the Mesh Editing software developed in Homework 2.
        To assist in developing our algorithms, we intend to use the following papers:
        <a href='http://graphics.uni-bielefeld.de/publications/sgp04.pdf' >Remeshing </a>
        and <a href='http://www.cs.cmu.edu/~./garland/Papers/quadrics.pdf' >Surface Simplification </a>
        </p>

    <h2 align="middle">Edge Collapse</h2>
      <h3 align="middle">Technical Approach</h3>
      <!-- A 1-2 page summary of your technical approach, techniques used, algorithms implemented, etc. (use references to papers or other resources for further detail). Highlight how your approach varied from the references used (did you implement a subset, or did you change or enhance anything), the unique decisions you made and why. -->

        <p>Using <a href="http://462cmu.github.io/asst2_meshedit/">Assignment 2 </a> of the CMU graphics class as a reference and the <a href="http://cs184.eecs.berkeley.edu/cs184_sp16/article/7/">Halfedge data structure</a>, we approached implementing Edge Collapse by keeping track of and correctly setting all pointers. These included the neighbor pointers (next, twin, edge, vertex, face) for all Halfedges, as well as the single Halfedge pointers for each face, edge and vertex. Our step-by-step approach can be summarized as follows:</p>
        <ol>
          <li>Draw a diagram of the to-be-collapsed edge and all adjacent elements; label each element with a name for clarity</li>
          <li>Gather the elements in code with those names.</li>
          <li>Using those names, reassign pointers to the arrangement required by the collapsed edge's neighborhood</li>
          <li>Finally, after reassignment is complete, it is safe to actually delete unneeded elements from the mesh</li>
        </ol>
        <p>There were two caveats to this process: first, boundary edges cannot be safely collapsed without violating the <a href="http://cs184.eecs.berkeley.edu/cs184_sp16/lecture/geometry/slide_056">manifold-ness</a> of the mesh, so we would return an empty VertexIter() in that case without modification. Second, certain conditions of geometry had to met before we could safely collapse; this was a completely independent process from checking pointers and in fact required usage of these <a href="http://stackoverflow.com/questions/27049163/mesh-simplification-edge-collapse-conditions">geometry principles</a>:</p>
        <ol>
          <li>The two vertices of the collapsed edge must share only two neighboring vertices. We performed this with a simple double nested for-loop over both the first and second vertex's neighbors.</li>
          <li>No triangles must be flipped as a result of the collapse. This was trickier to check for, and involved precalculating the triangle normal vectors of the 'before' and 'after' arrangements before any actual collapsing. By comparing the angle between the before and after normals, we were able to determine if this condition was violated and return appropriate values.</li>
        </ol>
        <p>These geometry conditions weren't actually mentioned in the CMU page, but were still crucial to maintaining manifold-ness after multiple collapses (especially on more complex meshes and mesh operations). Otherwise, our approach differed little from theirs, mostly because this was a fundamental operation with not a lot of freedom for other ways of implementation.</p>

      <h3 align="middle">Problems Encountered</h3>
      <!-- A description of problems encountered and how you tackled them. -->
        <p>We immediately encountered problems with pointers, either from incorrectly or neglecting setting them; this would result in nasty segfaults, or cause gaping holes to appear after successive collapses. Eventually we solved this by cleverly reducing the number of pointers we had to keep track of, since not all pointers needed to be set in order to make it work (e.g. the vertices on the outer perimeter of the neighborhood didn't need to be assigned anything at all). By being more surgical with our pointer assignments, it was easier to debug and ultimately pinpoint which pointers needed to be set in order to avoid the problems altogether.</p>
        <p> 
          Other problems arose when collapse had to be used in conjunction with other code (see below, edge collapse is foundational for both remeshing and simplification), mostly involving iteration and malloc errors; we solved these by handling cases where our iterators might run over already deleted elements, specifically by comparing the number of elements before and after one edge collapse. </p>
      <h3 align="middle">Lessons Learned</h3>
      <!-- A description of lessons learned. -->
        <p>The main takeaway from this modest but crucial part was simplicity: while our collapse code initially contained 200+ lines of code, we were later able to reduce this to less than 100. This was after spending time thinking about the special ways to take care of pointer assignments when certain elements were bound to be deleted. We chose to change as little pointers as possible and this proved to be the better approach.</p>

      <h3 align="middle">Results</h3>
        <div align="center">
            <table style="width=100%">
                <tr>
                    <td align="middle">
                    <img src="images/quadball1.png" width='800px'/>
                    <figcaption align="middle">Before collapse</figcaption>
                </tr>
                <tr>
                    <td align="middle">
                    <img src="images/quadball2.png" width='800px'/>
                    <figcaption align="middle">After collapse</figcaption>
                </tr>
            </table>
          </div>


    <h2 align="middle">Resampling via Isotropic Remeshing</h2>
      <h3 align="middle">Technical Approach</h3>
        <p> For remeshing, our approach was based on the paper <a url="http://graphics.uni-bielefeld.de/publications/disclaimer.php?dlurl=sgp04.pdf">here</a>. 
        At a simple level our algorithm was the following: </p>
        <ol>
        <li>Find the average edge length </li>
        <li>Split all edges that are longer than four thirds times the average</li>
        <li>Collapse edges shorter than four fifths the average</li>
        <li>If flipping an edge would bring the average vertex valence closer to 6, do so</li>
        <li>Lastly, move vertices to decrease the average distance to their neighbors</li>
        <li>Repeat</li>
        </ol>
      <h3 align="middle">Problems Encountered</h3>
        <p>The main issue we ran into with remeshing involved edge collapse.
        Collapsing edges as we iterated through the list of edges proved to be very prone to errors since collapsing one edge deletes three edges from the mesh.
        We eventually solved this by modifying our iterator in the case of a collapse so that we would not accidentally iterate over a no longer valid edge.</p>

      <h3 align="middle">Results</h3>
        <div align="center">
          <table style="width=100%">
              <tr>
                  <td align="middle">
                  <img src="images/cowremesh.png" width='800px'/>
                  <figcaption align="middle"></figcaption>
              </tr>
              <tr>
                  <td align="middle">
                  <img src="images/beanremesh.png" width='800px'/>
                  <figcaption align="middle">Notice how the triangles on top have become equilateral in the remeshed image (right)</figcaption>
              </tr>
          </table>
        </div>

    <h2 align="middle">Mesh Simplification</h2>
      <h3 align="middle">Technical Approach</h3>

      <h3 align="middle">Problems Encountered</h3>

      <h3 align="middle">Results</h3>

    <h2 align="middle">Sqrt(3) Upsampling</h2>
      <h3 align="middle">Technical Approach</h3>
      <p>For sqrt(3) upsampling, we modeled our algorithm after the paper <a url="https://www.graphics.rwth-aachen.de/media/papers/sqrt31.pdf">here</a>. 
      At a glance, sqrt(3) upsampling takes every triangle in the mesh and splits it into 3. 
      To accomplish this we designed our algorithm as follows:</p>
      <ol>
        <li>Iterate through each face of the mesh</li>
        <li>Add a new vertex to the mesh located at the center of the considered triangle</li>
        <li>Link each vertex of the original triangle to this new point with edges</li>
        <li>Delete unecessary elements and reassign pointers for the new structure.</li>
        <li>After doing this for all faces, flip all edges originally in the mesh that touch two vertices also originally in the mesh. </li>
      </ol>
      <div align="center">
          <table style="width=100%">
              <tr>
                  <td align="middle">
                  <img src="images/sqrt3figure.png" width='800px'/>
                  <figcaption align="middle">A figure depicting the transformation</figcaption>
              </tr>
          </table>
        </div>


      <h3 align="middle">Problems Encountered</h3>
      <p>We weren't able to get the smoothing algorithm working correctly in time, leading to a very bumpy surface.
      This is especially noticeable in the second run of sqrt(3) subdivision. </p>

      <h3 align="middle">Results</h3>
      <div align="center">
          <table style="width=100%">
              <tr>
                  <td align="middle">
                  <img src="images/sqrt3cow.png" width='800px'/>
                  <figcaption align="middle">Notice the bumps around the edges in sqrt(3)</figcaption>
              </tr>
              <tr>
                  <td align="middle">
                  <img src="images/sqrt3cow2.png" width='800px'/>
                  <figcaption align="middle"></figcaption>
              </tr>
          </table>
        </div>

    <h2 align="middle">Extra Shaders</h2>
      <h3 align="middle">Technical Approach</h3>

      <h3 align="middle">Problems Encountered</h3>

      <h3 align="middle">Results</h3>

    <h2 align="middle">References</h2>
      <a url="http://462cmu.github.io/asst2_meshedit/">CMU MeshEdit</a>
      <a url="http://graphics.uni-bielefeld.de/publications/disclaimer.php?dlurl=sgp04.pdf">Botsch and Kobbelt, "A Remeshing Approach to Multiresolution Modeling" </a>
      <a url="https://www.graphics.rwth-aachen.de/media/papers/sqrt31.pdf"> Sqrt(3)-Subdivision</a>

    <h2 align="middle">Contributions</h2>
      <p>Nag:</p>
      <p>Kenny: Implemented edge collapse with Nag and remeshing with Tim</p>
      <p>Tim: Implemented remeshing with Kenny, implemented Sqrt(3) subdivision</p>

    <h2 align="middle">Lessons Learned</h2>

</div>
</body>
</html>




